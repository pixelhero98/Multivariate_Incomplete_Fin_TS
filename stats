def diffusion_loss(model: LLapDiT, scheduler, x0_lat_norm: torch.Tensor, t: torch.Tensor,
                   *, cond_summary: Optional[torch.Tensor], predict_type: str = "v") -> torch.Tensor:
    """
    MSE on v/eps with channel-invariant reduction.
    Optional min-SNR weighting (set in crypto_config).
    """
    noise = torch.randn_like(x0_lat_norm)
    x_t, eps_true = scheduler.q_sample(x0_lat_norm, t, noise)
    pred = model(x_t, t, cond_summary=cond_summary, sc_feat=None)
    target = eps_true if predict_type == "eps" else scheduler.v_from_eps(x_t, t, eps_true)

    # [B,H,Z] -> per-sample loss: mean over H, sum over Z  (scale-invariant to Z)
    err = (pred - target).pow(2)              # [B,H,Z]
    per_sample = err.mean(dim=1).sum(dim=1)   # [B]

    # Optional: min-SNR weighting to prevent early-t domination
    if getattr(crypto_config, "USE_MIN_SNR", False):
        abar = scheduler.alpha_bars[t]                                   # [B]
        snr  = abar / (1.0 - abar).clamp_min(1e-8)
        gamma = float(getattr(crypto_config, "MIN_SNR_GAMMA", 5.0))
        w = torch.minimum(snr, torch.as_tensor(gamma, device=snr.device, dtype=snr.dtype))
        w = w / (snr + 1.0)                                             # keeps magnitude reasonable
        return (w.detach() * per_sample).mean()
    else:
        return per_sample.mean()
